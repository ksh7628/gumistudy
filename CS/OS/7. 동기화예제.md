- [ì„œë¡ ](#--)

- [ì±•í„° ëª©í‘œ](#-----)

- [7.1 Classic Problem of Synchronization](#71-classic-problem-of-synchronization)
  * [7.1.1 The Bounded-Buffer Problem](#711-the-bounded-buffer-problem)
  * [7.1.2 The Readers-Writers Problem](#712-the-readers-writers-problem)
  * [7.1.3 The Dining-Philosophers Problem](#713-the-dining-philosophers-problem)
  
- [7.2 Synchronization within the Kernel](#72-synchronization-within-the-kernel)
  * [7.2.1 Synchronization in Windows](#721-synchronization-in-windows)
  * [7.2.2 Synchronization in LINUX](#722-synchronization-in-linux)
  
- [7.3 POSIX Synchronization](#73-posix-synchronization)
  * [7.3.1 POSIX Mutex Locks](#731-posix-mutex-locks)
  * [7.3.2 POSIX Semaphores](#732-posix-semaphores)
  * [7.3.3 POSIX Condition Variables](#733-posix-condition-variables)
  
- [7.4 Synchronization in Java](#74-synchronization-in-java)
  * [7.4.1 Java Monitors](#741-java-monitors)
  * [7.4.2 Reentrant Locks: The Simplest locking mechanism in the API](#742-reentrant-locks--the-simplest-locking-mechanism-in-the-api)
  * [7.4.3 Semaphores](#743-semaphores)
  * [7.4.4 Condition Variables](#744-condition-variables)
  
- [7.5 Alternative Approaches: Hardware Support](#75-alternative-approaches--hardware-support)
  * [7.5.1 Transactional Memory](#751-transactional-memory)
  * [7.5.2 OpenMP](#752-openmp)
  * [7.5.3 Functional Programming Language](#753-functional-programming-language)
  
- [7.6 Summary](#76-summary)

  

## ì„œë¡ 

ì±•í„° 6ì—ì„œëŠ” ciritical-section problemê³¼ ì–´ë–»ê²Œ race conditionì´ ì¼ì–´ë‚  ìˆ˜ ìˆëŠ”ì§€ ê·¸ë¦¬ê³  race condition ì˜ˆë°© ë°©ë²•ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì•˜ë‹¤. race condition ì˜ˆë°© ë°©ë²•ì—ëŠ” low level ë¶€í„° high levelë¡œ êµ¬ë¶„í•˜ì—¬ ì¡´ì¬í•˜ëŠ”ë° low levelë¡œëŠ” memory barrier, compare and swap operationì´ ìˆì—ˆê³ , high levelë¡œëŠ” mutex lock, semaphores, monitorsê°€ ìˆì—ˆë‹¤.

ì´ë²ˆ ì±•í„°ì—ì„œëŠ” ìœ„ ë°©ë²•ë“¤ì„ ì‹¤ì œë¡œ classic problemì— ì ìš©í•  ê²ƒì´ë‹¤. ë˜í•œ ê° ìš´ì˜ì²´ì œê°€ ì‚¬ìš©í•˜ëŠ” ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜, Javaì™€ POSIXê°€ ì‚¬ìš©í•˜ëŠ” APIë¥¼ ì•Œì•„ë³¼ ì˜ˆì •ì´ë‹¤.

## ì±•í„° ëª©í‘œ

- Classic Synchronization Problem ì•Œì•„ë³´ê¸°
  - Bounded Buffer, Readers-Writers, Dining-Philosophers Problem
- ë¦¬ëˆ…ìŠ¤ì™€ ìœˆë„ìš°ê°€ ë™ê¸°í™” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸°ìœ„í•´ ì–´ë–¤ ë°©ë²•ë“¤ì„ ì‚¬ìš©í•˜ëŠ”ì§€ ì•Œì•„ë³´ê¸°
- ë™ê¸°í™”ë¬¸ì œë¥¼ í’€ê¸° ìœ„í•´ POSIXì™€ Javaê°€ ì–´ë–»ê²Œ í•˜ëŠ”ì§€ ì•Œì•„ë³´ê¸°
- POSIXì™€ Java APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ê¸°í™” ë¬¸ì œ í•´ê²°ì±… ë””ìì¸í•´ë³´ê¸°

## 7.1 Classic Problem of Synchronization

### 7.1.1 The Bounded-Buffer Problem

producer(ë²„í¼ë¥¼ ì±„ìš°ëŠ” ì‚¬ëŒ)ê°€ bufferë¥¼ ê°€ë“ ì±„ìš°ê±°ë‚˜ consumer(ë²„í¼ ë‚´ìš©ì„ ê°€ì ¸ê°€ëŠ” ì‚¬ëŒ)ê°€ ë²„í¼ë¥¼ ë¹„ìš°ëŠ” ê²½ìš°

### 7.1.2 The Readers-Writers Problem

DBì˜ writerê°€ ë°ì´í„°ë¥¼ ë°”ê¾¸ê³  ìˆëŠ”ë° readerê°€ ì½ëŠ” ê²½ìš°

â†’ Reader-Writer lockì„ ë‘ì–´ì„œ ìì‹ ì˜ ëª¨ë“œì— ë”°ë¼ ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

â†’ ì˜¤ì§ í•˜ë‚˜ì˜ ì‘ì—…ë§Œì´ lockì„ ê°€ì§ˆ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë™ì‹œì— ë³´ëŠ” ì¼ì€ ì—†ìŒ!

â†’ Reader-Writer lockì´ ìœ ìš©í•œ ê²½ìš°: writerë³´ë‹¤ readerê°€ ë” ë§ì€ ê²½ìš°, only writer + only reader

### 7.1.3 The Dining-Philosophers Problem

(gif íŒŒì¼)

ì—°ê´€ëœ ë¬¸ì œ: Deadlock, starvation

7.1.3.1 Semaphore Solution

ì “ê°€ë½ í•œ ì§ì„ semaphoreí•˜ë‚˜ë¡œ ë‘”ë‹¤ `semaphore chopstick[5];`

ì “ê°€ë½ ì¡ëŠ” ê±° == wait()

ì “ê°€ë½ ë†“ëŠ” ê±° == signal()

â†’ ìµœëŒ€ 4ëª…ë§Œ ì•‰ê²Œí•˜ê¸°(ì “ê°€ë½ì´ 5ê°œì¼ ë•Œ)

â†’ ì “ê°€ë½ 2ê°œê°€ ì‚¬ìš©ê°€ëŠ¥í•  ë•Œë§Œ ì ‘ê·¼ê°€ëŠ¥í•˜ë„ë¡ í•˜ê¸° (pick up in critical-section)

â†’ ìš°ì„ ìˆœìœ„ë¥¼ ë‘ê¸° ex. í™€ìˆ˜ ì² í•™ìê°€ ë¨¼ì € ë“¤ê²Œ í•˜ê¸°

7.1.3.2 Monitor Solution

enum { `thinking`, `hungry`, `eating` } state[5];

ë¨¹ê¸° ì „ == pickup()

ë¨¹ì€ í›„ == putdown()

â†’ eating ì„¤ì •ì„ ë‘ ì´ì›ƒì´ ë¨¹ëŠ” ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì„¤ì • ê°€ëŠ¥í•˜ê²Œ í•œë‹¤

## 7.2 Synchronization within the Kernel

### 7.2.1 Synchronization in Windows

- ë©€í‹°ìŠ¤ë ˆë“œ ì»¤ë„ â†’ ì‹¤ì‹œê°„ ì–´í”Œë¦¬ì¼€ì´ì…˜, ë‹¤ì¤‘ í”„ë¡œì„¸ì„œ ì§€ì›

- Kernel uses spinlock only to protect short code segment, spinlock hoding ì‹œ ìŠ¤ë ˆë“œ ì„ ì  ë¶ˆê°€

  ğŸ”” spinlock ì„ê³„êµ¬ì—­ì— ì§„ì…ì´ ë¶ˆê°€ëŠ¥í•  ë•Œ ì§„ì…ì´ ê°€ëŠ¥í•  ë•Œê¹Œì§€ ë£¨í”„ë¥¼ ëŒë©´ì„œ ì¬ì‹œë„í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ëœ ê²½ìš°

- Dispatcher Object: mutex lock, semaphore, events, timer

- Critical-Section Object (user mode mutex): spinì´ ê¸¸ì–´ì§€ëŠ” ê²½ìš° ì‚¬ìš©í•˜ëŠ” êµ¬ì¡°ì²´

### 7.2.2 Synchronization in LINUX

ver2.6 ì´ì „ ë¹„ì„ ì í˜• ì»¤ë„ â†’ fully preemptive!

- Atomic Integer: ëª¨ë“  ìˆ˜í•™ì  ì—°ì‚°ì€ ë°©í•´ ì—†ì´ ì‘ë™í•¨
- mutex lock: `mutext_lock() â†’ critical-section â†’ mutext_unlock()`
- spinlock: SMP machine
- semaphore

ë¦¬ëˆ…ìŠ¤ ì‚¬ì§„)

## 7.3 POSIX Synchronization

### 7.3.1 POSIX Mutex Locks

Mutex Lockì€ ì„ê³„ êµ¬ì—­ì„ ë³´í˜¸í•˜ê¸° ìœ„í•˜ì—¬ ì‚¬ìš©ëœë‹¤.

```jsx
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
/* critical section */
pthread_mutex_unlock(&mutex);
```

### 7.3.2 POSIX Semaphores

7.3.2.1 POSIX Named Semaphores

sem = sem_open("SEM", O_CREAT, 0666, 1); :ì´ë¦„, ì´ˆê¸°í™” ì†ì„±, read, writer access

semaphoreì— ì´ë¦„ì„ ë¶€ì—¬í•˜ê¸° ë•Œë¬¸ì— ì‚¬ìš©í•˜ê¸° ì‰½ë‹¤.

LINUX, MacOSì— ëª¨ë‘ ì‚¬ìš©í•˜ê³  ìˆë‹¤.

7.3.2.2 POSIX Unnamed Semaphores

sem = sem_init(&sem, 0, 1) :semaphore pointer, level, initial value

### 7.3.3 POSIX Condition Variables

ì§€ë‚œ ì±•í„°ì—ì„œ ë‹¤ë£¬ condition variableì€ ëª¨ë‹ˆí„°ì˜ í•œ ë¶€ë¶„ìœ¼ë¡œ ì ê¸ˆ ë©”ì»¤ë‹ˆì¦˜ì— ì‚¬ìš©ë˜ëŠ” ë³€ìˆ˜ì˜€ì§€ë§Œ Pthreadsê°€ ì‚¬ìš©í•˜ëŠ” condition variableì€ ëŒ€ë¶€ë¶„ C í™˜ê²½ì—ì„œ ì‘ì„±ë˜ë¯€ë¡œ ëª¨ë‹ˆí„°ê°€ ì§€ì›ë˜ì§€ ì•Šê¸°ë•Œë¬¸ì— lockingì„ condition variableê³¼ mutex lockìœ¼ë¡œ êµ¬í˜„í•œë‹¤.

## 7.4 Synchronization in Java

### 7.4.1 Java Monitors

ìë°”ì˜ `BoundedBuffer` í´ë˜ìŠ¤ëŠ” bounded-buffer problemì„ í•´ê²°í•œë‹¤.

ëª¨ë“  ìë°”ì˜ ê°ì²´ëŠ” single lockê³¼ ê´€ë ¨ì´ ìˆë‹¤. `synchronized` ë¡œ ì„ ì–¸í•œ ë©”ì†Œë“œì˜ ê²½ìš°, ê°ì²´ ì ê¸ˆì„ ì œê³µí•œë‹¤.

ë§Œì•½ ì‚¬ìš©í•˜ê³ ì í•˜ëŠ” ê°ì²´ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì— ì˜í•´ ì‚¬ìš©ë˜ê³  ìˆë‹¤ë©´ entry setì´ë¼ëŠ” ê³³ì—ì„œ ê¸°ë‹¤ë¦°ë‹¤.

- ë§Œì•½ì— ìŠ¤ë ˆë“œê°€ waitë¥¼ í˜¸ì¶œí•˜ëŠ” ê²½ìš°

1. ìŠ¤ë ˆë“œëŠ” ê°ì²´ë¥¼ ì ê¸ˆì„ í•´ì œí•œë‹¤.
2. ìŠ¤ë ˆë“œì˜ ìƒíƒœê°€ ë‹«íŒë‹¤(blocked)
3. ìŠ¤ë ˆë“œê°€ ê°ì²´ì˜ wait setì— ìë¦¬ ì¡ëŠ”ë‹¤.

- ë§Œì•½ì— ìŠ¤ë ˆë“œê°€ notifyë¥¼ í˜¸ì¶œí•˜ëŠ” ê²½ìš°

1. wait setì— ìˆëŠ” ìŠ¤ë ˆë“œ ì¤‘ ì„ì˜ì˜ í•˜ë‚˜ë¥¼ ì„ íƒí•œë‹¤.

`Synchronized` ë¼ê³  ì„ ì–¸í•œ ë©”ì†Œë“œëŠ” wait()ì™€ notify()ë¥¼ ê°€ì§„ë‹¤.

ì°¸ê³ ì‚¬ì§„) 392 page ì½”ë“œ ì‚½ì…

393page wait setì´ ëª¨ë‹ˆí„°ì— ë¶™ì€ ì‚¬ì§„

### 7.4.2 Reentrant Locks: The Simplest locking mechanism in the API

ReentrantLock acts like the `synchronized` statement. ì™œëƒë©´ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì™€ ë…ë¦½ì ìœ¼ë¡œ ê³µìœ  ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

Reentrant Locksì˜ íŠ¹ì§•: fairness parameter (ì„ì˜ì˜ ìŠ¤ë ˆë“œê°€ ì•„ë‹ˆë¼ ìˆœì„œë¥¼ ë‘ê¸° ìœ„í•˜ì—¬)

ReentrantLockì€ Lock ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†ë°›ëŠ”ë‹¤.

394page key.lock() ì½”ë“œ ì‚½ì…

### 7.4.3 Semaphores

Java APIëŠ” counting semaphoreë¥¼ ì œê³µí•œë‹¤.(ìŒìˆ˜ í—ˆìš©)

### 7.4.4 Condition Variables

Condition VariablesëŠ” ê¸°ëŠ¥ì ìœ¼ë¡œ wait()ì™€ notify()ë¥¼ ë‹®ì•˜ë‹¤.

Java ëŠ” named condition variableì„ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.

## 7.5 Alternative Approaches: Hardware Support

ì½”ì–´ê°€ ë” ë§ì•„ì§ˆ ìˆ˜ë¡ ê³ ë ¤í•´ì•¼í•˜ëŠ” ê²ƒë“¤ì´ ë§ì•„ì ¸ì„œ ì†Œí”„íŠ¸ì›¨ì–´ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ì—†ì„ ìˆ˜ ë„ ìˆë‹¤.

### 7.5.1 Transactional Memory

Transactional Memory: atomicí•˜ê²Œ ì½ê³  ì“¸ ìˆ˜ ìˆëŠ” ì—°ì†ì ì¸ ë©”ëª¨ë¦¬

Mutex Lockì´ë‚˜ semaphoreë¥¼ ì“°ë©´ ë°ë“œë½ì˜ ìœ„í—˜ì„ í”¼í•  ìˆ˜ ì—†ëŠ”ë°

ê³µìœ í•˜ê³  ìˆëŠ” ê°’ì´ Transactional Memoryì•ˆì— ë“¤ì–´ê°€ ìˆë‹¤ë©´? â†’ ë°©í•´ë°›ì§€ ì•Šê³  ì™„ì „í•œ ì—°ì‚°ì´ ë³´ì¥ëœë‹¤.

Software Transactional Memory(STM): ì´ë¦„ì²˜ëŸ¼ Softwareì— TMì„ êµ¬í˜„í•œ ê²ƒ, transaction blockì—ë‹¤ê°€ ì—°ì‚°ì½”ë“œë¥¼ ì§‘ì–´ë„£ëŠ”ë‹¤. low-level lockingì´ í•„ìš”í•˜ë‹¤.

Hardware Transactional Memory(HTM): ê³„ì¸µí™” ìºì‹œì™€ cache coherency protocolsê°€ í•„ìš”í•˜ë‹¤.

### 7.5.2 OpenMP

OpenMPëŠ” ë³‘ë ¬ í”„ë¡œê·¸ë˜ë°ì„ ì§€ì›í•˜ëŠ” ì»´íŒŒì¼ëŸ¬ì™€ APIì˜ ëª¨ìŒì´ë‹¤.

`#pragma omp parallel` ì´ë¼ê³  ì„ ì–¸í•˜ë©´ ë³‘ë ¬ ì˜ì—­ì„ ì„ ì–¸í•œê²ƒì´ê³  ë‹¤ìˆ˜ì˜ ìŠ¤ë ˆë“œê°€ ë©€í‹° ì½”ì–´ ì²˜ëŸ¼ ì‘ë™í•œë‹¤. ì´ë•Œ ì¥ì ì€ ìŠ¤ë ˆë“œì˜ ê´€ë¦¬ë¥¼ OpenMP ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•´ì¤€ë‹¤ëŠ” ê²ƒì´ë‹¤.

### 7.5.3 Functional Programming Language

Erlang, Scala

## 7.6 Summary

1. ë™ê¸°í™”ë¥¼ ì²˜ë¦¬í•  ë•Œ ìƒê¸°ëŠ” Classic Problem ì—ëŠ” the bounded-buffer, readers-writers, Dining-philosopher problemì´ ìˆë‹¤. ì´ë“¤ì˜ í•´ê²°ì±…ìœ¼ë¡œëŠ” mutex lock, semaphore, monitors, condition variableê³¼ ê°™ì€ ë„êµ¬ë“¤ì„ ì‚¬ìš©í•œë‹¤.
2. ìœˆë„ìš°ëŠ” dispatcher object ë¿ë§Œ ì•„ë‹ˆë¼ eventsë¥¼ ì ìš©í•˜ì—¬ ë™ê¸°í™”ë¥¼ í•´ê²°í•œë‹¤.
3. ë¦¬ëˆ…ìŠ¤ëŠ” race conditionì„ í•´ê²°í•˜ê¸° ìœ„í•˜ì—¬, atomic variables, spinlock, mutex locksì„ ì‚¬ìš©í•œë‹¤.
4. POSIX APIëŠ” mutex lock, semaphore, condition variablesë¥¼ ì œê³µí•œë‹¤. POSIX APIëŠ” named semaphoreì™€ unnamed semaphore ë‘ ê°€ì§€ í˜•íƒœì˜ semaphoreë¥¼ ì œê³µí•œë‹¤. named semaphoreë¥¼ ì´ìš©í•˜ì—¬ ì—°ê´€ì—†ëŠ” ìŠ¤ë ˆë“œ ê°„ì—ë„ ì´ë¦„ë§Œ ì°¸ì¡°í•˜ë©´ ì‰½ê²Œ ì—°ê²°í•  ìˆ˜ ìˆë‹¤. unnamed semaphoreë¥¼ ì‚¬ìš©í•˜ë©´ ì‰½ê²Œ ê³µìœ ë  ìˆ˜ëŠ” ì—†ì§€ë§Œ ë°ì´í„°ì˜ ê³µìœ  êµ¬ì—­ì„ ì •í•´ì¤„ ìˆ˜ ìˆë‹¤.
5. ìë°”ëŠ” ë™ê¸°í™”ë¥¼ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ë„êµ¬ë“¤ì´ í’ë¶€í•˜ë‹¤: monitors, reentrant locks, semaphores, condition variables
6. ë‹¤ë¥¸ ëŒ€ì•ˆìœ¼ë¡œëŠ” transactional memory, OpenMP, functional language(Erlang, Scala)ê°€ ìˆë‹¤. í•¨ìˆ˜í˜• ì–¸ì–´ëŠ” ìƒíƒœë¥¼ ìœ ì§€í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— race conditionì´ë‚˜ critical section ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.